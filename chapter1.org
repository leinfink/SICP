#+TITLE: Structure and Interpretation of Computer Programs
#+STARTUP: nohideblocks

#+name: commentify
#+begin_src emacs-lisp :var result="" :exports none
(concat ";=> " (format "%s" result))
#+end_src

#+RESULTS: commentify
: ;=> 

/Attribution:/ Harold Abelson and Gerald Jay Sussman with Julie Sussman, foreword by Alan J. Perlis, Â©1996 by The Massachusetts Institute of Technology, licensed under the Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0). Notes, (modified or adjusted) excerpts, and exercises by @leinfink.

* Chapter 1.1 The Elements of Programming
:PROPERTIES:
:header-args:scheme: :session *sicp1* :post commentify(*this*) 
:END:
- primitive expressions
- means of combination
- means of abstraction

- procedures
- data
  
** 1.1.1 Expressions
- /primitive expressions/ can get combined into combinations with operators and operands
- the value of a combination is obtained by /applying/ the procedure that is the value of the operator  to the arguments that are the values of the operands
- Lisp: /prefix notation/, allows for an aribtrary number of arguments and for easy nesting
  
** 1.1.2 Naming and the Environment
- /names/ identify /variables/ whose /value/ is a computational object
- these associations are stored in the /environment/
  
** 1.1.3 Evaluating Combinations
- general evaluation rule (for combinations) :: 1. /Evaluate/ the subexpressions of the combination. 2. /Apply/ the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpression.
  - recursive, tree accumulation
- values of primitive expressions:
  - numerals: the number they name
  - built-in operators: the respective machine instruction sequences
  - other names: the objects associated with the names in the environment
- special forms :: (combined) expressions that have special evaluation rules
  - e.g. =(define)= does not apply a procedure to its arguments, but associates a variable with a value
    
** 1.1.4 Compound Procedures
- procedure definitions :: associating names (in the corresponding environment) with compound procedures
- general form of a procedure definition (in Scheme):
  - =(define (<name> <formal parameters>) <body>)=
  
** 1.1.5 The Substitution Model for Procedure Application
- application rule for primitive procedures: built into the interpreter
- /apply/ / application rule for compound procedures :: to apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument
  - so-called /substitution model/ for procedure application
  - that is, a simplified /model/, not usually literally what happens inside an interpreter
  - for instance, instead of literally replacing the formal parameters with the arguments, a /local environment/ is used
- applicative-order evaluation :: evaluate first the operator and operands, the apply the resulting procedure to the resulting arguments
- normal-order evaluation :: evaluate the operator, but don't immediately evaluate the operands. instead, substitute operand expressions for parameters, then evaluate operators as needed until you reach expressions involving only primitive operators, only then evaluate the operands
- Lisp uses applicative-order evaluation: simpler, avoids multiple evalutions, but has some limitations (e.g. for "infinite" /streams/)

** 1.1.6 Conditional Expressions and Predicates
- /case analysis/ in Lisp: =cond=
- predicates :: procedures that return true or false, expressions that evaluate to true or false
    
*** Exercise 1.1
#+begin_src scheme
  10 ; 10
  (+ 5 3 4) ; 12
  (- 9 1) ; 8
  (/ 6 2) ; 3
  (+ (* 2 4) (- 4 6)) ; 6
#+end_src

#+RESULTS:
: ;=> 6

#+begin_src scheme :exports both
  (define a 3)
  (define b (+ a 1))
  (+ a b (* a b))
#+end_src

#+RESULTS:
: ;=> 19

#+begin_src scheme :exports both
  (= a b)
#+end_src

#+RESULTS:
: ;=> #f

#+begin_src scheme :exports both
  (if (and (> b a) (< b (* a b)))
      b
      a)
#+end_src

#+RESULTS:
: ;=> 4

#+begin_src scheme :exports both
  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
#+end_src

#+RESULTS:
: ;=> 16

#+begin_src scheme :exports both
  (+ 2 (if (> b a) b a))
#+end_src

#+RESULTS:
: ;=> 6

#+begin_src scheme :exports both
  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
#+end_src

#+RESULTS:
: ;=> 16

*** Exercise 1.2
#+begin_src scheme :exports both
  (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
     (/ 3 (- 6 2) (- 2 7)))
#+end_src

#+RESULTS:
: ;=> -296/3

*** Exercise 1.3
#+begin_src scheme :exports both
  (define (square a)
    (* a a))

  (define (sum-of-squares a b)
    (+ (square a) (square b)))

  (define (larger-squares-sum a b c)
    "Returns the sum of the squares of the two larger numbers."
    (cond ((or (<= a b) (<= a c)) (sum-of-squares b c))
          ((or (<= b a) (<= b c)) (sum-of-squares a c))
          (else (sum-of-squares a b))))

  (larger-squares-sum 2 3 4)
#+end_src

#+RESULTS:
: ;=> 25

*** Exercise 1.4
For positive /b/, the procedure uses addition, otherwise subtraction as its operator.

#+begin_src scheme
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+end_src

#+RESULTS:
: ;=> #<void>

*** Exercise 1.5
#+begin_src scheme
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
        0
        y))
#+end_src

#+RESULTS:
: ;=> #<void>

=(test 0 (p))= would loop indefinitely in applicative-order evaluation (as in Scheme), because the argument gets evaluated when the function is called, not only once it's used in the body. In normal-oder evaluation, y would never get evaluated because the if-condition is true. =test= would return 0.

** 1.1.7 Example: Square Roots using Newton's Method
Iteration can be accomplished simply using the ability to call a procedure.

#+begin_src scheme :exports both
  (define (average x y)
    (/ (+ x y) 2))

  (define (sqrt x)
    (define (improve guess)
      (average guess (/ x guess)))

    (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))

    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))

    (sqrt-iter 1.0))
  
  (sqrt 9)
#+end_src

  #+RESULTS:
  : ;=> 3.00009155413138

  #+begin_src scheme :exports both
    (square (sqrt 0.001))
  #+end_src

  #+RESULTS:
  : ;=> 0.0017011851721075596

  Quite nice, but not yet perfect for small numbers.

*** Exercise 1.6
#+begin_src scheme
  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))
#+end_src

#+RESULTS:
: ;=> #<void>

Because =new-if= is not a special form (unlike =if=), all the arguments get evaluated, so =sqrt-iter= would get called indefinitely if it used =new-if= instead of =if=.

*** Exercise 1.7
#+begin_src scheme :exports both
  (define (better-sqrt x)
     (define (improve guess)
       (average guess (/ x guess)))

     (define (good-enough? guess old-guess)
       (< (/ (abs (- guess old-guess)) guess)
          1/10000))

     (define (sqrt-iter guess old-guess)
       (if (good-enough? guess old-guess)
           guess
           (sqrt-iter (improve guess) guess)))

     (sqrt-iter 1.0 2.0)) ; 2.0 just so the first "change" is 1

  (square (better-sqrt 0.001))
#+end_src

#+RESULTS:
: ;=> 0.001000000000000034

Better!

*** Exercise 1.8
#+begin_src scheme :exports both
  (define (cube a)
    (* a a a))

  (define (cbrt x)
    (define (good-enough? guess)
      (< (abs (- (cube guess) x)) 0.001))

    (define (improve guess)
      (/ (+ (/ x (square guess))
            (* 2 guess))
         3))

    (define (iter guess)
      (if (good-enough? guess)
          guess
          (iter (improve guess))))

    (iter 1.0))

  (cbrt 27)
#+end_src

#+RESULTS:
: ;=> 3.0000005410641766

Yay!

** 1.1.8 Procedures as Black-Box Abstractions
- local names :: the names of the procedure's formal parameters should not matter to the user of the procedure
- bound variable :: a formal parameter of a procedure, have the body of the procedure as their /scope/
- free variable :: a variable that is not bound by the procedure definition
- /block structure/ :: nesting of definitions within definitions to hide them from external use
- lexical scoping :: free variables in a procedure refer to bindings made by enclosing procedure definitions -> they get looked up in the environment in which the procedure was defined (not in the environment in which it was called, as in dynamic scoping)
  
* Chapter 1.2
:PROPERTIES:
:header-args:scheme: :session *sicp2* :post commentify(*this*) 
:END:
** 1.2.1 Linear Recursion and Iteration
#+begin_src scheme
  (define (factorial-recursive n)
    (if (= n 1)
        1
        (* n (factorial-recursive (- n 1)))))

  (define (factorial-iterative n)
    (define (iter product counter)
      (if (> counter n)
          product
          (iter (* counter product)
                (+ counter 1))))
    (iter 1 1))
#+end_src

#+RESULTS:
: ;=> #<void>
 
- recursive process :: builds up a chain of /deferred operations/, requires space to keep track of the deferred operations
- linear recursive process :: recursive process where the amount of space neeed to keep track of the deferred operations grows linearly with /n/ / is proportional to /n/, as does the amount of steps required
- iterative process :: the state is encapsulated at all times in a fixed number of /state variables/, plus a description of update behaviors, and termination condition. space requirement is fixed.
- linear iterative process :: iterative process where the number of steps grows lineraly with /n/

- A recursive /process/ is not the same as a recursive /procedure/. =factorial-iterative= has a recursive procedure definition, but the process it generates is iterative.
- To allow for iterative processes to be generated by recursive procedure definitions, an implementation needs to be /tail-recursive/ (special iteration constructs can then be omitted).
  
*** Exercise 1.9
Generates a /recursive process/ for addition in terms of =inc= and =dec=:

#+begin_src scheme :session none :exports both
      (define (inc a) (+ a 1))

      (define (dec a) (- a 1))

      (define (plus a b)
        (if (= a 0)
            b
            (inc (plus (dec a) b))))

      (plus 2 3)
#+end_src

#+RESULTS:
: ;=> 5

Generates an /iterative process/ for addition in terms of =inc= and =dec=:

#+begin_src scheme :session none :exports both
  (define (inc a) (+ a 1))

  (define (dec a) (- a 1))

  (define (plus a b)
    (if (= a 0)
        b
        (plus (dec a) (inc b))))

  (plus 2 3)
#+end_src

#+RESULTS:
: ;=> 5

** Exercise 1.10 Ackermann's function
#+begin_src scheme
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1) (A x (- y 1))))))
#+end_src

#+RESULTS:
: ;=> #<void>

- 2n:
#+begin_src scheme
  (define (f n) (A 0 n))
#+end_src

#+RESULTS:
: ;=> #<void>

- 2^n:
  
  (y0: 0,  y1: 2,  y2: (* 2 2) = 4,  y3: (* 2 4),  y4: (* 2 8),  ...)
#+begin_src scheme
  (define (g n) (A 1 n))
#+end_src

#+RESULTS:
: ;=> #<void>

- 2^(2^n):
  
  (y0: 0,  y1: 2,  y2: (A 1 2) = 4,  y3: (A 1 (2^2)) = 2^4,  y4: (A 1 (2^3)) = 2^8,  ...)
#+begin_src scheme
  (define (h n) (A 2 n))
#+end_src

#+RESULTS:
: ;=> #<void>

** Fibonacci
Tree-recursive process: The number of steps grows exponentially, space use linearly.
#+begin_src scheme
  (define (fib-rec n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib-rec (- n 1))
                   (fib-rec (- n 2))))))

  (fib-rec 5)
#+end_src

#+RESULTS:
: ;=> 5

Linear iterative process: The number of steps grows linearly, space use is constant.
#+begin_src scheme
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  
  (define (fib-it n)
    (fib-iter 1 0 n))

  (fib-it 5)
#+end_src

#+RESULTS:
: ;=> 5

** Example: Counting Change
Writing a procedure that calculates how many different ways there are of changing x amount of money with n different types of coins.

#+begin_src scheme :exports both
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (define (cc amount kinds-of-coins)
    (cond
     ;; no money counts as 1 way of changing it
     ((= amount 0) 1)
     ;; neg money or no coin-kinds is 0 ways of changing it
     ((or (< amount 0) (= kinds-of-coins 0)) 0)
     (else (+ (cc amount
                  (- kinds-of-coins 1))
              (cc (- amount
                     (first-denomination
                      kinds-of-coins))
                  kinds-of-coins)))))

  (define (count-change amount) (cc amount 5))

  (count-change 200)
#+end_src

#+RESULTS:
: ;=> 2435

** Exercise 1.11
#+begin_src scheme :exports both :session none
  (define (func-rec n)
    (if (< n 3)
        n
        (+ (func-rec (- n 1))
           (* 2 (func-rec (- n 2)))
           (* 3 (func-rec (- n 3))))))

  (func-rec 10)
#+end_src

#+RESULTS:
: ;=> 1892

#+begin_src scheme :exports both :session none
  (define (func-iter n)
    (define (iter i prev1 prev2 prev3)
      (if (= i (+ n 1))
          prev1
          (iter (+ i 1)
                (if (< i 3)
                    i
                    (+ prev1
                       (* 2 prev2)
                       (* 3 prev3)))
                prev1
                prev2)))
    (iter 0 0 0 0))

  (func-iter 10)
#+end_src

#+RESULTS:
: ;=> 1892

** Exercise 1.12 - Pascal's Triangle

#+begin_src scheme :exports both
  ;; h: height, x: steps from left
  (define (pascal-triangle-element h x) 
    (if (or (= x 1) (= x h))
        1
        (+ (pascal-triangle-element (- h 1) (- x 1))
           (pascal-triangle-element (- h 1) x))))

  (pascal-triangle-element 22 13)
#+end_src

#+RESULTS:
: ;=> 293930

** TODO Exercise 1.13

** TODO Exercise 1.14

** Exercise 1.15

#+begin_src scheme :exports both :results output
  (define (cube x) (* x x x))

  (define (p x)
    (display "p ")
    (- (* 3 x) (* 4 (cube x))))

  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))

  (display (sine 12.15))
#+end_src

#+RESULTS:
: ;=> p p p p p -0.39980345741334

1. =p= is applied 5 times when =(sine 12.15)= is evaluated.
2. TODO

** Exponentiation
Recursive, O(n) steps, O(n) space:
#+begin_src scheme
  (define (expt-rec b n)
    (if (= n 0)
        1
        (* b (expt-rec b (- n 1)))))
#+end_src

#+RESULTS:
: ;=> #<void>

Iterative, O(n) steps, O(1) space:
#+begin_src scheme
  (define (expt-iter b n)
    (define (iter counter product)
      (if (= counter 0)
          product
          (iter (- counter 1)
                (* b product))))
    (iter n 1))
#+end_src

#+RESULTS:
: ;=> #<void>

Logarithmic, time O(log n):
#+begin_src scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))
#+end_src

#+RESULTS:
: ;=> #<void>

** TODO Exercise 1.16
#+begin_src scheme :exports both 
    (define (fast-expt-iter b n)
      (define (iter counter state)
        (cond ((= counter 0) 1)
              ((even? counter) (square n))))
      nil)
#+end_src

#+RESULTS:
: ;=> #<void>
