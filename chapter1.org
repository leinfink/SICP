#+TITLE: Structure and Interpretation of Computer Programs
#+STARTUP: nohideblocks

#+name: commentify
#+begin_src emacs-lisp :var result="" :exports none
(concat ";=> " (format "%s" result))
#+end_src

#+RESULTS: commentify
: ;=> 

/Attribution:/ Harold Abelson and Gerald Jay Sussman with Julie Sussman, foreword by Alan J. Perlis, ©1996 by The Massachusetts Institute of Technology, licensed under the Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0). Notes, (modified or adjusted) excerpts, and exercises by @leinfink.

* Chapter 1
:PROPERTIES:
:header-args:scheme: :session *sicp1* :post commentify(*this*) 
:END:
** Chapter 1.1 The Elements of Programming
- primitive expressions
- means of combination
- means of abstraction

- procedures
- data
  
*** 1.1.1 Expressions
- /primitive expressions/ can get combined into combinations with operators and operands
- the value of a combination is obtained by /applying/ the procedure that is the value of the operator  to the arguments that are the values of the operands
- Lisp: /prefix notation/, allows for an aribtrary number of arguments and for easy nesting
  
*** 1.1.2 Naming and the Environment
- /names/ identify /variables/ whose /value/ is a computational object
- these associations are stored in the /environment/
  
*** 1.1.3 Evaluating Combinations
- general evaluation rule (for combinations) :: 1. /Evaluate/ the subexpressions of the combination. 2. /Apply/ the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpression.
  - recursive, tree accumulation
- values of primitive expressions:
  - numerals: the number they name
  - built-in operators: the respective machine instruction sequences
  - other names: the objects associated with the names in the environment
- special forms :: (combined) expressions that have special evaluation rules
  - e.g. =(define)= does not apply a procedure to its arguments, but associates a variable with a value
    
*** 1.1.4 Compound Procedures
- procedure definitions :: associating names (in the corresponding environment) with compound procedures
- general form of a procedure definition (in Scheme):
  - =(define (<name> <formal parameters>) <body>)=
  
*** 1.1.5 The Substitution Model for Procedure Application
- application rule for primitive procedures: built into the interpreter
- /apply/ / application rule for compound procedures :: to apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument
  - so-called /substitution model/ for procedure application
  - that is, a simplified /model/, not usually literally what happens inside an interpreter
  - for instance, instead of literally replacing the formal parameters with the arguments, a /local environment/ is used
- applicative-order evaluation :: evaluate first the operator and operands, the apply the resulting procedure to the resulting arguments
- normal-order evaluation :: evaluate the operator, but don't immediately evaluate the operands. instead, substitute operand expressions for parameters, then evaluate operators as needed until you reach expressions involving only primitive operators, only then evaluate the operands
- Lisp uses applicative-order evaluation: simpler, avoids multiple evalutions, but has some limitations (e.g. for "infinite" /streams/)

*** 1.1.6 Conditional Expressions and Predicates
- /case analysis/ in Lisp: =cond=
- predicates :: procedures that return true or false, expressions that evaluate to true or false
    
**** DONE Exercise 1.1
#+begin_src scheme
  10 ; 10
  (+ 5 3 4) ; 12
  (- 9 1) ; 8
  (/ 6 2) ; 3
  (+ (* 2 4) (- 4 6)) ; 6
#+end_src

#+RESULTS:
: ;=> 6

#+begin_src scheme :exports both
  (define a 3)
  (define b (+ a 1))
  (+ a b (* a b))
#+end_src

#+RESULTS:
: ;=> 19

#+begin_src scheme :exports both
  (= a b)
#+end_src

#+RESULTS:
: ;=> #f

#+begin_src scheme :exports both
  (if (and (> b a) (< b (* a b)))
      b
      a)
#+end_src

#+RESULTS:
: ;=> 4

#+begin_src scheme :exports both
  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
#+end_src

#+RESULTS:
: ;=> 16

#+begin_src scheme :exports both
  (+ 2 (if (> b a) b a))
#+end_src

#+RESULTS:
: ;=> 6

#+begin_src scheme :exports both
  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
#+end_src

#+RESULTS:
: ;=> 16

**** DONE Exercise 1.2
#+begin_src scheme :exports both
  (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
     (/ 3 (- 6 2) (- 2 7)))
#+end_src

#+RESULTS:
: ;=> -296/3

**** DONE Exercise 1.3
#+begin_src scheme :exports both
  (define (square a)
    (* a a))

  (define (sum-of-squares a b)
    (+ (square a) (square b)))

  (define (larger-squares-sum a b c)
    "Returns the sum of the squares of the two larger numbers."
    (cond ((or (<= a b) (<= a c)) (sum-of-squares b c))
          ((or (<= b a) (<= b c)) (sum-of-squares a c))
          (else (sum-of-squares a b))))

  (larger-squares-sum 2 3 4)
#+end_src

#+RESULTS:
: ;=> 25

**** DONE Exercise 1.4
For positive /b/, the procedure uses addition, otherwise subtraction as its operator.

#+begin_src scheme
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+end_src

#+RESULTS:
: ;=> #<void>

**** DONE Exercise 1.5
#+begin_src scheme
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
        0
        y))
#+end_src

#+RESULTS:
: ;=> #<void>

=(test 0 (p))= would loop indefinitely in applicative-order evaluation (as in Scheme), because the argument gets evaluated when the function is called, not only once it's used in the body. In normal-oder evaluation, y would never get evaluated because the if-condition is true. =test= would return 0.

*** 1.1.7 Example: Square Roots using Newton's Method
Iteration can be accomplished simply using the ability to call a procedure.

#+begin_src scheme :exports both
  (define (average x y)
    (/ (+ x y) 2))

  (define (sqrt x)
    (define (improve guess)
      (average guess (/ x guess)))

    (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))

    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))

    (sqrt-iter 1.0))
  
  (sqrt 9)
#+end_src

  #+RESULTS:
  : ;=> 3.00009155413138

  #+begin_src scheme :exports both
    (square (sqrt 0.001))
  #+end_src

  #+RESULTS:
  : ;=> 0.0017011851721075596

  Quite nice, but not yet perfect for small numbers.

**** DONE Exercise 1.6
#+begin_src scheme
  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))
#+end_src

#+RESULTS:
: ;=> #<void>

Because =new-if= is not a special form (unlike =if=), all the arguments get evaluated, so =sqrt-iter= would get called indefinitely if it used =new-if= instead of =if=.

**** DONE Exercise 1.7
#+begin_src scheme :exports both
  (define (better-sqrt x)
     (define (improve guess)
       (average guess (/ x guess)))

     (define (good-enough? guess old-guess)
       (< (/ (abs (- guess old-guess)) guess)
          1/10000))

     (define (sqrt-iter guess old-guess)
       (if (good-enough? guess old-guess)
           guess
           (sqrt-iter (improve guess) guess)))

     (sqrt-iter 1.0 2.0)) ; 2.0 just so the first "change" is 1

  (square (better-sqrt 0.001))
#+end_src

#+RESULTS:
: ;=> 0.001000000000000034

Better!

**** DONE Exercise 1.8
#+begin_src scheme :exports both
  (define (cube a)
    (* a a a))

  (define (cbrt x)
    (define (good-enough? guess)
      (< (abs (- (cube guess) x)) 0.001))

    (define (improve guess)
      (/ (+ (/ x (square guess))
            (* 2 guess))
         3))

    (define (iter guess)
      (if (good-enough? guess)
          guess
          (iter (improve guess))))

    (iter 1.0))

  (cbrt 27)
#+end_src

#+RESULTS:
: ;=> 3.0000005410641766

Yay!

*** 1.1.8 Procedures as Black-Box Abstractions
- local names :: the names of the procedure's formal parameters should not matter to the user of the procedure
- bound variable :: a formal parameter of a procedure, have the body of the procedure as their /scope/
- free variable :: a variable that is not bound by the procedure definition
- /block structure/ :: nesting of definitions within definitions to hide them from external use
- lexical scoping :: free variables in a procedure refer to bindings made by enclosing procedure definitions -> they get looked up in the environment in which the procedure was defined (not in the environment in which it was called, as in dynamic scoping)
  
** Chapter 1.2
*** 1.2.1 Linear Recursion and Iteration
#+begin_src scheme
  (define (factorial-recursive n)
    (if (= n 1)
        1
        (* n (factorial-recursive (- n 1)))))

  (define (factorial-iterative n)
    (define (iter product counter)
      (if (> counter n)
          product
          (iter (* counter product)
                (+ counter 1))))
    
    (iter 1 1))
#+end_src

#+RESULTS:
: ;=> #<void>
 
- recursive process :: builds up a chain of /deferred operations/, requires space to keep track of the deferred operations
- linear recursive process :: recursive process where the amount of space neeed to keep track of the deferred operations grows linearly with /n/ / is proportional to /n/, as does the amount of steps required
- iterative process :: the state is encapsulated at all times in a fixed number of /state variables/, plus a description of update behaviors, and termination condition. space requirement is fixed.
- linear iterative process :: iterative process where the number of steps grows lineraly with /n/

- A recursive /process/ is not the same as a recursive /procedure/. =factorial-iterative= has a recursive procedure definition, but the process it generates is iterative.
- To allow for iterative processes to be generated by recursive procedure definitions, an implementation needs to be /tail-recursive/ (special iteration constructs can then be omitted).
  
**** DONE Exercise 1.9
Generates a /recursive process/ for addition in terms of =inc= and =dec=:

#+begin_src scheme :session none :exports both
  (define (inc a) (+ a 1))

  (define (dec a) (- a 1))

  (define (plus a b)
    (if (= a 0)
        b
        (inc (plus (dec a) b))))

  (plus 2 3)
#+end_src

#+RESULTS:
: ;=> 5

Generates an /iterative process/ for addition in terms of =inc= and =dec=:

#+begin_src scheme :session none :exports both
  (define (inc a) (+ a 1))

  (define (dec a) (- a 1))

  (define (plus a b)
    (if (= a 0)
        b
        (plus (dec a) (inc b))))

  (plus 2 3)
#+end_src

#+RESULTS:
: ;=> 5

**** DONE Exercise 1.10 Ackermann's function
#+begin_src scheme
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))

#+end_src

#+RESULTS:
: ;=> #<void>

- 2n:
#+begin_src scheme
  (define (f n) (A 0 n))
#+end_src

#+RESULTS:
: ;=> #<void>

- 2^n:
  
#+begin_src scheme
  (define (g n) (A 1 n))
#+end_src

#+RESULTS:
: ;=> #<void>

- 2^(2^n):
  
#+begin_src scheme
  (define (h n) (A 2 n))
#+end_src

#+RESULTS:
: ;=> #<void>

*** 1.2.2 Tree Recursion
**** Fibonacci
Tree-recursive process: The number of steps grows exponentially, space use linearly.
#+begin_src scheme
  (define (fib-rec n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib-rec (- n 1))
                   (fib-rec (- n 2))))))

  (fib-rec 5)
#+end_src

#+RESULTS:
: ;=> 5

Linear iterative process: The number of steps grows linearly, space use is constant.
#+begin_src scheme
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  
  (define (fib-it n)
    (fib-iter 1 0 n))

  (fib-it 5)
#+end_src

#+RESULTS:
: ;=> 5

**** Example: Counting Change
Writing a procedure that calculates how many different ways there are of changing x amount of money with n different types of coins.

#+begin_src scheme :exports both
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (define (cc amount kinds-of-coins)
    (cond
     ;; no money counts as 1 way of changing it
     ((= amount 0) 1)
     ;; neg money or no coin-kinds is 0 ways of changing it
     ((or (< amount 0) (= kinds-of-coins 0)) 0)
     (else (+ (cc amount
                  (- kinds-of-coins 1))
              (cc (- amount
                     (first-denomination
                      kinds-of-coins))
                  kinds-of-coins)))))

  (define (count-change amount) (cc amount 5))

  (count-change 200)
#+end_src

#+RESULTS:
: ;=> 2435

**** DONE Exercise 1.11
#+begin_src scheme :exports both :session none
  (define (func-rec n)
    (if (< n 3)
        n
        (+ (func-rec (- n 1))
           (* 2 (func-rec (- n 2)))
           (* 3 (func-rec (- n 3))))))

  (func-rec 10)
#+end_src

#+RESULTS:
: ;=> 1892

#+begin_src scheme :exports both :session none
  (define (func-iter n)
    (define (iter i prev1 prev2 prev3)
      (if (= i (+ n 1))
          prev1
          (iter (+ i 1)
                (if (< i 3)
                    i
                    (+ prev1
                       (* 2 prev2)
                       (* 3 prev3)))
                prev1
                prev2)))
    (iter 0 0 0 0))

  (func-iter 10)
#+end_src

#+RESULTS:
: ;=> 1892

***** DONE Exercise 1.12 - Pascal's Triangle
#+begin_src scheme :exports both
  ;; h: height, x: steps from left
  (define (pascal-triangle-element h x) 
    (if (or (= x 1) (= x h))
        1
        (+ (pascal-triangle-element (- h 1) (- x 1))
           (pascal-triangle-element (- h 1) x))))

  (pascal-triangle-element 22 13)
#+end_src

#+RESULTS:
: ;=> 293930

***** TODO Exercise 1.13
- ideas: =(exact-integer-sqrt 5)= is 2 with remainder of 1.
  
*** 1.2.3 Orders of Growth
- n :: parameter that measures the size of the problem
- R(n) :: the amount of resources the process requires for a problem of size /n/
- R(n) = Θ(f(n)) if there are positive constants /k1/ and /k2/ independent of /n/ such that $k1f(n) <= R(n) <= k2f(n)$ for any sufficiently large value of /n/ :: R(n) has order of growth Θ(f(n))

In other words: For any big /n/, the resources needed will be between $k1 * f(n)$  and $k2 * f(n)$ some two positive constants /k1/ and /k2/. It doesn't matter what these positive constants are, but they have to exist. But this means that for all the processes for which /R(n) = Θ(f(n))/ holds for $f(n) = n$, the same holds for $f(n) = c * n$, where c is some constant factor. That is, all processes with an order of growth of /f(n)/ also have order of growth of /f(c*n)/, that is, the two functions describe the same group of processes, so we can probably reduce it just to $f(n) = n$, or Θ(n).

- orders of growth provide only a crude description of the behavior of a process (and processes with the same order of growth can still require vastly different amounts of resources)
- but they are useful to indicate how changing the size of the problem would change the resource use of the process

- Θ(n) :: linear process, doubling n will roughly double the amount of resources
- Θ(n^2) :: expontential process, incrementing n will multiply resources by a constant factor
- Θ(log(n)) :: logarithmic process, doubling n will increase resources by a constant amount
  
**** TODO Exercise 1.14
**** DONE Exercise 1.15
- State "DONE"       from "TODO"       [2023-01-08 Sun 18:14]
  
#+begin_src scheme :exports both :results output
  (define (cube x) (* x x x))

  (define (p x)
    (display "p ")
    (- (* 3 x) (* 4 (cube x))))

  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))

  (display (sine 12.15))
#+end_src

#+RESULTS:
: ;=> p p p p p -0.39980345741334

1. =p= is applied 5 times when =(sine 12.15)= is evaluated.
2. To get the order of growth in time for =(sine a)= relative to /a/, we first note that the recursive call to =sine= is the thing that will be relevant, as both =cube= and =p= just use a constant amount of steps for each call. =sine= is called as often as is needed to repeatedly divide /angle/ by 3.0 until it (or its absolute value) is smaller or equal to 0.1. So if we triple /angle/, we will need one more step, so the order of growth is $log_3(n)$. Same goes for order of growth in space, as every call to =p= is deferred until a small enough angle is reached.
   
*** 1.2.4 Exponentiation
Linear recursive process,  Θ(n) steps, Θ(n) space:
#+begin_src scheme
  (define (expt-rec b n)
    (if (= n 0)
        1
        (* b (expt-rec b (- n 1)))))
#+end_src

#+RESULTS:
: ;=> #<void>

Linear iterative process, Θ(n) steps, Θ(1) space:
#+begin_src scheme
  (define (expt-iter b n)
    (define (iter counter product)
      (if (= counter 0)
          product
          (iter (- counter 1)
                (* b product))))
    (iter n 1))
#+end_src

#+RESULTS:
: ;=> #<void>

Logarithmic, time Θ(log n) steps, Θ(log n) space:
#+begin_src scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))
#+end_src

#+RESULTS:
: ;=> #<void>

Computing $b^2n$  with =fast-expt= only needs one more multiplication than computing $b^n$. Every new step allows for (roughly) double the problem size. Therefore, its order of growth is the logarithm of /n/ to the base 2, Θ(log n). The base to which logarithms are taken does not matter (because of the arbitrary constants /k1/ and /k2/), so we just write Θ(log n). [ TODO: I don't think I understand that last sentence yet. I get why a constant factor like 2n would be equal to n, but this seems different? ]

**** DONE Exercise 1.16
- State "DONE"       from "TODO"       [2023-01-08 Sun 22:01]
#+begin_src scheme :exports both 
  (define (fast-expt-iter b n)
    (define (iter b n a)
      (cond ((= n 0) a)
            ((even? n) (iter (square b) (/ n 2) a))
            (else (iter b (- n 1) (* b a)))))
    (iter b n 1))

  (fast-expt-iter 2 2)
#+end_src

#+RESULTS:
: ;=> 4

- /invariant quantity/ :: Helpful technique for designing an iterative algorithm. In this case, /a/ * /b^n/ always stays the same (iterative algorithm: the complete state is always available), and at the end all the computation has moved "into" /a/, as b^n will be 1 when n=0, so we can return /a/.

**** DONE Exercise 1.17
- State "DONE"       from "TODO"       [2023-01-08 Sun 22:22]
#+begin_src scheme :exports both :session none
  (define (* a b)
    (if (= b 0)
        0
        (+ a (* a (- b 1)))))
#+end_src

#+RESULTS:
: ;=> #<void>

#+begin_src scheme :exports both 
  (define (double n) (* 2 n))

  (define (halve n) (/ n 2))

  (define (fast-multiplication a b)
    (cond ((= 0 b) 0)
          ((even? b) (double (fast-multiplication a (halve b))))
          (else (+ a (fast-multiplication a (- b 1))))))

  (fast-multiplication 150 231)
#+end_src

#+RESULTS:
: ;=> 34650

**** DONE Exercise 1.18  "Russian peasant multiplication"
- State "DONE"       from "TODO"       [2023-01-08 Sun 22:38]

#+begin_src scheme :exports both 
  (define (fast-multiplication-iterative a b)
    (define (iter a b z)
      (cond ((= b 0) z)
            ((even? b) (iter (double a) (halve b) z))
            (else (iter a (- b 1) (+ z a)))))
    (iter a b 0))

  (fast-multiplication-iterative 7098 9388)
#+end_src

#+RESULTS:
: ;=> 66636024

**** DONE Exercise 1.19 Fibonacci numbers in logarithmic number of steps

- State "DONE"       from "TODO"       [2023-01-09 Mon 10:31]
Transformation T for Fibonacci numbers:
=T: a <- a + b
   b <- a=

This is a special case of transformation T_pq, where p = 0 and q = 1.

=T_pq: a <- bq + aq + ap
      b <- bp + aq=

Applying a transformation T_pq twice ("squaring" it) gives:

=a2: (bp + aq) * q + (bq + aq + ap) * q + (bq + aq + ap) * p=
=b2: (bp + aq) * p + (bq + aq + ap) * q=

Which is equal to:

=a2:  b(q^2 + 2pq) + a(p^2 + q^2) +  a(q^2 + 2pq)==
=b2:  b(p^2 + q^2) + a(q^2 + 2pq)==

So it can be expressed as another transformation T with

=p' : p^2 + q^2=
=q' : q^2 + 2pq=

Used in a sucessive-squaring algorithm:

#+begin_src scheme :exports both
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (square p) (square q))
                     (+ (square q) (* 2 p q))
                     (/ count 2)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))

  (define (fib n)
    (fib-iter 1 0 0 1 n))

  (fib 100)
#+end_src

#+RESULTS:
: ;=> 354224848179261915075

**** 

