#+TITLE: Structure and Interpretation of Computer Programs
#+STARTUP: nohideblocks

#+name: commentify
#+begin_src emacs-lisp :var result="" :exports none
(concat ";=> " (format "%s" result))
#+end_src

#+RESULTS: commentify
: ;=> 


* Chapter 1.1
:PROPERTIES:
:header-args:scheme: :session *sicp1* :post commentify(*this*) 
:END:

** Exercise 1.1
#+begin_src scheme
  10 ; 10
  (+ 5 3 4) ; 12
  (- 9 1) ; 8
  (/ 6 2) ; 3
  (+ (* 2 4) (- 4 6)) ; 6
#+end_src

#+RESULTS:
: ;=> 6

#+begin_src scheme :exports both
  (define a 3)
  (define b (+ a 1))
  (+ a b (* a b))
#+end_src

#+RESULTS:
: ;=> 19

#+begin_src scheme :exports both
  (= a b)
#+end_src

#+RESULTS:
: ;=> #f

#+begin_src scheme :exports both
  (if (and (> b a) (< b (* a b)))
      b
      a)
#+end_src

#+RESULTS:
: ;=> 4

#+begin_src scheme :exports both
  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
#+end_src

#+RESULTS:
: ;=> 16

#+begin_src scheme :exports both
  (+ 2 (if (> b a) b a))
#+end_src

#+RESULTS:
: ;=> 6

#+begin_src scheme :exports both
  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))
#+end_src

#+RESULTS:
: ;=> 16

** Exercise 1.2
#+begin_src scheme :exports both
  (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
     (/ 3 (- 6 2) (- 2 7)))
#+end_src

#+RESULTS:
: ;=> -296/3

** Exercise 1.3
#+begin_src scheme :exports both
  (define (square a)
    (* a a))

  (define (sum-of-squares a b)
    (+ (square a) (square b)))

  (define (larger-squares-sum a b c)
    "Returns the sum of the squares of the two larger numbers."
    (cond ((or (<= a b) (<= a c)) (sum-of-squares b c))
          ((or (<= b a) (<= b c)) (sum-of-squares a c))
          (else (sum-of-squares a b))))

  (larger-squares-sum 2 3 4)
#+end_src

#+RESULTS:
: ;=> 25

** Exercise 1.4
For positive /b/, the procedure uses addition, otherwise subtraction as its operator.

#+begin_src scheme
  (define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))
#+end_src

#+RESULTS:
: ;=> #<void>

** Exercise 1.5
#+begin_src scheme
  (define (p) (p))

  (define (test x y)
    (if (= x 0)
        0
        y))
#+end_src

#+RESULTS:
: ;=> #<void>

=(test 0 (p))= would loop indefinitely in applicative-order evaluation (as in Scheme), because the argument gets evaluated when the function is called, not only once it's used in the body. In normal-oder evaluation, y would never get evaluated because the if-condition is true. =test= would return 0.

** Example: Square Roots using Newton's Method
#+begin_src scheme :exports both
  (define (average x y)
    (/ (+ x y) 2))

  (define (sqrt x)
    (define (improve guess)
      (average guess (/ x guess)))

    (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))

    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))

    (sqrt-iter 1.0))
  
  (sqrt 9)
#+end_src

  #+RESULTS:
  : ;=> 3.00009155413138

  #+begin_src scheme :exports both
    (square (sqrt 0.001))
  #+end_src

  #+RESULTS:
  : ;=> 0.0017011851721075596

  Quite nice, but not yet perfect for small numbers.

** Exercise 1.6
#+begin_src scheme
  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))
#+end_src

#+RESULTS:
: ;=> #<void>

Because =new-if= is not a special form (unlike =if=), all the arguments get evaluated, so =sqrt-iter= would get called indefinitely if it used =new-if= instead of =if=.

** Exercise 1.7
#+begin_src scheme :exports both
  (define (better-sqrt x)
     (define (improve guess)
       (average guess (/ x guess)))

     (define (good-enough? guess old-guess)
       (< (/ (abs (- guess old-guess)) guess)
          1/10000))

     (define (sqrt-iter guess old-guess)
       (if (good-enough? guess old-guess)
           guess
           (sqrt-iter (improve guess) guess)))

     (sqrt-iter 1.0 2.0)) ; 2.0 just so the first "change" is 1

  (square (better-sqrt 0.001))
#+end_src

#+RESULTS:
: ;=> 0.001000000000000034

Better!

** Exercise 1.8
#+begin_src scheme :exports both
  (define (cube a)
    (* a a a))

  (define (cbrt x)
    (define (good-enough? guess)
      (< (abs (- (cube guess) x)) 0.001))

    (define (improve guess)
      (/ (+ (/ x (square guess))
            (* 2 guess))
         3))

    (define (iter guess)
      (if (good-enough? guess)
          guess
          (iter (improve guess))))

    (iter 1.0))

  (cbrt 27)
#+end_src

#+RESULTS:
: ;=> 3.0000005410641766

Yay!

* Chapter 1.2
:PROPERTIES:
:header-args:scheme: :session *sicp2* :post commentify(*this*) 
:END:
** Recursive and Iterative Processes
#+begin_src scheme
  (define (factorial-recursive n)
    (if (= n 1)
        1
        (* n (factorial-recursive (- n 1)))))

  (define (factorial-iterative n)
    (define (iter product counter)
      (if (> counter n)
          product
          (iter (* counter product)
                (+ counter 1))))
    (iter 1 1))
#+end_src

#+RESULTS:
: ;=> #<void>

** Exercise 1.9
Recursive:

#+begin_src scheme :session none :exports both
  (define (+ a b)
    (if (= a 0) b (1+ (+ (1- a) b))))
  
  (+ 2 3)
#+end_src

#+RESULTS:
: ;=> 5

Iterative:

#+begin_src scheme :session none :exports both
    (define (+ a b)
      (if (= a 0) b (+ (1- a) (1+ b))))

    (+ 2 3)
#+end_src

#+RESULTS:
: ;=> 5

** Exercise 1.10
#+begin_src scheme
  (define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1) (A x (- y 1))))))
#+end_src

- 2n:
#+begin_src scheme
  (define (f n) (A 0 n))
#+end_src

- 2^n:
  
  (y0: 0,  y1: 2,  y2: (* 2 2) = 4,  y3: (* 2 4),  y4: (* 2 8),  ...)
#+begin_src scheme
  (define (g n) (A 1 n))
#+end_src

- 2^(2^n):
  
  (y0: 0,  y1: 2,  y2: (A 1 2) = 4,  y3: (A 1 (2^2)) = 2^4,  y4: (A 1 (2^3)) = 2^8,  ...)
#+begin_src scheme
  (define (h n) (A 2 n))
#+end_src

** Fibonacci
Tree-recursive process: The number of steps grows exponentially, space use linearly.
#+begin_src scheme
  (define (fib-rec n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib-rec (- n 1))
                   (fib-rec (- n 2))))))
#+end_src

#+RESULTS:
: ;=> #<void>

Linear iterative process: The number of steps grows linearly, space use is constant.
#+begin_src scheme
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  (define (fib-it n)
    (fib-iter 1 0 n))
#+end_src

#+RESULTS:
: ;=> #<void>

** Example: Counting Change
Writing a procedure that calculates how many different ways there are of changing x amount of money with n different types of coins.

#+begin_src scheme :exports both
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (define (cc amount kinds-of-coins)
    (cond
     ;; no money counts as 1 way of changing it
     ((= amount 0) 1)
     ;; neg money or no coin-kinds is 0 ways of changing it
     ((or (< amount 0) (= kinds-of-coins 0)) 0)
     (else (+ (cc amount
                  (- kinds-of-coins 1))
              (cc (- amount
                     (first-denomination
                      kinds-of-coins))
                  kinds-of-coins)))))

  (define (count-change amount) (cc amount 5))

  (count-change 200)
#+end_src

#+RESULTS:
: ;=> 2435

** Exercise 1.11
#+begin_src scheme :exports both :session none
  (define (func-rec n)
    (if (< n 3)
        n
        (+ (func-rec (- n 1))
           (* 2 (func-rec (- n 2)))
           (* 3 (func-rec (- n 3))))))

  (func-rec 10)
#+end_src

#+RESULTS:
: ;=> 1892

#+begin_src scheme :exports both :session none
  (define (func-iter n)
    (define (iter i prev1 prev2 prev3)
      (if (= i (+ n 1))
          prev1
          (iter (+ i 1)
                (if (< i 3)
                    i
                    (+ prev1
                       (* 2 prev2)
                       (* 3 prev3)))
                prev1
                prev2)))
    (iter 0 0 0 0))

  (func-iter 10)
#+end_src

#+RESULTS:
: ;=> 1892

** Exercise 1.12 - Pascal's Triangle

#+begin_src scheme :exports both
  ;; h: height, x: steps from left
  (define (pascal-triangle-element h x) 
    (if (or (= x 1) (= x h))
        1
        (+ (pascal-triangle-element (- h 1) (- x 1))
           (pascal-triangle-element (- h 1) x))))

  (pascal-triangle-element 22 13)
#+end_src

#+RESULTS:
: ;=> 293930

** TODO Exercise 1.13

** TODO Exercise 1.14

** Exercise 1.5

#+begin_src scheme :exports both :results output
  (define (cube x) (* x x x))

  (define (p x)
    (display "p ")
    (- (* 3 x) (* 4 (cube x))))

  (define (sine angle)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0)))))

  (display (sine 12.15))
#+end_src

#+RESULTS:
: ;=> p p p p p -0.39980345741334

1. =p= is applied 5 times when =(sine 12.15)= is evaluated.
2. TODO

** Exponentiation
Recursive, O(n) steps, O(n) space:
#+begin_src scheme
  (define (expt-rec b n)
    (if (= n 0)
        1
        (* b (expt-rec b (- n 1)))))
#+end_src

#+RESULTS:
: ;=> #<void>

Iterative, O(n) steps, O(1) space:
#+begin_src scheme
  (define (expt-iter b n)
    (define (iter counter product)
      (if (= counter 0)
          product
          (iter (- counter 1)
                (* b product))))
    (iter n 1))
#+end_src

#+RESULTS:
: ;=> #<void>

Logarithmic, time O(log n):
#+begin_src scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))
#+end_src

#+RESULTS:
: ;=> #<void>

** TODO Exercise 1.16
#+begin_src scheme :exports both 
    (define (fast-expt-iter b n)
      (define (iter counter state)
        (cond ((= counter 0) 1)
              ((even? counter) (square n))))
      nil)
#+end_src

#+RESULTS:
: ;=> #<void>
